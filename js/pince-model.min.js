/** * Pince calculator * @author Simone Pandolfi <simopandolfi@gmail.com> */     function dist(p1, p2) { return Math.sqrt(Math.pow(p1.x - p2.x, 2) + Math.pow(p1.y - p2.y, 2)); }     var w = view.size.width, h = view.size.height;   function drawPath() { var w_front_neck = parseInt($("#model-data input[name='w_front_neck']").val()), h_front_neck = parseInt($("#model-data input[name='h_front_neck']").val()), l_breast = parseInt($("#model-data input[name='l_breast']").val()), w_breast = parseInt($("#model-data input[name='w_breast']").val()), w_shoulder = parseInt($("#model-data input[name='w_shoulder']").val()), h_front_shoulder_slope = parseInt($("#model-data input[name='h_front_shoulder_slope']").val()), pince_gap = parseInt($("#model-data input[name='pince_gap']").val()), h_half_waistline = parseInt($("#model-data input[name='h_half_waistline']").val());   var A = new Point(0, h_front_neck), B = new Point(w_front_neck, 0), C = new Point(B.x, A.y);  var aux_ang = Math.asin((w_breast - w_front_neck) / l_breast);  var D = new Point(0, l_breast * Math.cos(aux_ang)), E = new Point(w_breast, D.y);  aux_ang = Math.asin(h_front_shoulder_slope / w_shoulder);  var F = new Point(B.x + w_shoulder * Math.cos(aux_ang), 0), G = new Point(F.x, h_front_shoulder_slope);  var H = new Point(E.x, (G.y - B.y) * ((E.x - B.x) / (G.x - B.x)) + B.y);  var aux = dist(E, H); aux_ang = 2 * Math.asin(pince_gap / (2 * aux));  var I = new Point(E.x + aux * Math.sin(aux_ang), E.y - aux * Math.cos(aux_ang)), L = new Point(E.x + (G.x - E.x) * Math.cos(aux_ang) - (G.y - E.y) * Math.sin(aux_ang), E.y + (G.x - E.x) * Math.sin(aux_ang) + (G.y - E.y) * Math.cos(aux_ang));  var M = new Point(L.x, L.y + h_half_waistline);  var N = new Point((I.x - E.x) * ((M.y - E.y) / (I.y - E.y)) + E.x, M.y), O = new Point((H.x - E.x) * ((M.y - E.y) / (H.y - E.y)) + E.x, M.y);   var points = { 'A': A, 'B': B, 'C': C, 'D': D, 'E': E, 'F': F, 'G': G, 'H': H, 'I': I, 'L': L, 'M': M, 'N': N, 'O': O, };  var lines = [ ['A', 'C', 'B', 'F'], ['B', 'G'], ['D', 'E', 'H'], ['E', 'I', 'L', 'M'], ['A', 'D'], ];  var dashed = [ ['M', 'N'], ];   var max_x = -1; for (var p in points) { if (points[p].x > max_x) max_x = points[p].x; }  var offset = (w - max_x) / 2;  for (var p in points) { points[p].x = -1 * points[p].x + max_x + offset; }   project.activeLayer.removeChildren();   for (var i = 0; i < lines.length; i++) { var path = new Path(); path.strokeColor = '#21B3FC'; for (var j = 0; j < lines[i].length; j++) { path.add(points[lines[i][j]]); } }  for (var i = 0; i < dashed.length; i++) { var path = new Path(); path.strokeColor = 'grey'; path.dashArray = [10, 12]; for (var j = 0; j < dashed[i].length; j++) { path.add(points[dashed[i][j]]); } }  var path = new Path(); path.strokeColor = 'red'; path.add(N); path.add(O);  pince_len = dist(N, O);  var text = new PointText(new Point(O.x + 5, O.y)); text.fillColor = 'red'; text.content = ((Math.floor((pince_len - Math.floor(pince_len)) * 10) < 5) ? (Math.floor(pince_len)) : (Math.ceil(pince_len))) + 'mm';     view.draw(); }    drawPath();   $("#model-data").submit(function(ev) { ev.preventDefault(); drawPath(); });  $("#model-data input[type='text']").keydown(function(ev) { if ((ev.keyCode < 48 || ev.keyCode > 57) &&  (ev.keyCode != 8) &&  (ev.keyCode != 9) &&  (ev.keyCode != 13) && (ev.keyCode != 37) && (ev.keyCode != 39) &&  (ev.keyCode != 116)) ev.preventDefault(); }); 